#!/usr/bin/sh

SEARCH_PATH="$HOME/Music"
SEARCH_EXT="wav\|mp3\|flac\|ogg"

ZIK_DIR="$HOME/.zik"
QUEUE="$ZIK_DIR/fifo"
COVERS="$ZIK_DIR/covers"
DAEMON_PID_FILE="$ZIK_DIR/daemon_pid"
FFPLAY_PID_FILE="$ZIK_DIR/ffplay_pid"

notif() {
    notify-send "Zik" "$1"
}

# Write file to fifo
add() {
    if [ -f "$1" ]; then
        # It has to running in background because the player
        # might not have started yet
        echo "$1" > "$QUEUE"
        notif "Added $1"
    elif [ -d "$1" ]; then
        notif "This is a directory $1" 
    fi
}

# dmenu prompt to select audio file to add to queue
menuadd() {
    add "$(find "$SEARCH_PATH/" -regex ".*\.\($SEARCH_EXT\)" | # Find audio files
        awk -F '/' '{printf "%-60s%s\n", $NF, $0}'           | # Rewrite as 'file   fullpath'
        dmenu -i -l 30 -p "Choose audio file"                | # Prompt user
        sed 's#^\([^/]*\)\(.*\)$#\2#'                          # Extract back the fullpath
    )"
}

# Send signal to the ffplay child process
# SIGSTOP and SIGCONT actually work pause/resume ffplay.
killffplay() {
    if [ -f "$FFPLAY_PID_FILE" ] && ps -p $(cat "$FFPLAY_PID_FILE") > /dev/null
    then
        kill $1 $(cat "$FFPLAY_PID_FILE")
    fi
}

# Get cover from the web. $1: artist, $2 album, $3 output path
wgetcover() {
    [ -z "$1" ] && [ -z "$2" ] && return 1

    # Find the MusicBrainz ID of the album
    URL="http://musicbrainz.org/ws/2/release-group/?query=artist:$1+release-group:$2&limit=1"

    # Look for <release-group id="xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    MBID=$(wget -qO - "$URL" |
        sed -n 's/.*<release-group id="\([^"]*\)".*/\1/p'
    )

    # Fetch the image from coverartarchive.org,
    # if wget fails (exit != 0) then no image found
    IMAGE_URL="https://coverartarchive.org/release-group/$MBID/front"
    return $(wget -qO "$3" "$IMAGE_URL") 
}

# Extract metadata, generate and cache album cover art
gencover() {
    META=$(ffmpeg -loglevel error -i "$1" -f ffmetadata -)
    ARTIST=$(echo "$META" | sed -n 's/^ARTIST=\(.*\)$/\1/Ip')
    ALBUM=$(echo  "$META" | sed -n 's/^ALBUM=\(.*\)$/\1/Ip')

    if [ -n "$ARTIST" ] && [ -n "$ALBUM" ]; then
        COVER="$COVERS/$(\
            echo "$ARTIST-$ALBUM.jpg"   |
            tr '[:upper:]' '[:lower:]'  |
            tr -cd '[:alnum:]._-'
        )"
    else
        # If artist or album missing from metadata,
        # save with the audio file name itself
        BASENAME=$(basename "$1")
        COVER="$COVERS/$BASENAME.jpg"
    fi

    # If doesn't exist already, extract from the audio file or get from the web
    if [ -f "$COVER" ] || 
        ffmpeg -y -i "$1" -vframes 1 -f image2 "$COVER" 2> /dev/null ||
        wgetcover "$ARTIST" "$ALBUM" "$COVER"
    then
        # notif "Found cover $COVER"
        echo "$COVER"
    else
        notif "No cover found for $1"
    fi
}


# Run in the background when needed and stop swhen when the queue is empty.
daemon() {
    # Exit cleanly
    trap 'killffplay -TERM; exit' TERM INT EXIT QUIT

    # Open queue for reading : when doing read directly on $QUEUE the fifo is 
    # opened then closed so other processes trying to write are blocked.
    exec 3< "$QUEUE"

    # For each file in the queue do...
    # Exit the loop when everything has been read.
    while read -u 3 FILE; do
        [ -f "$FILE" ] || continue
        notif "Now playing $FILE" 

        # Set cover as wallpaper
        # FIXME: unhack this make it run in the background
        ( COVER=$(gencover "$FILE")
        if [ -n "$COVER" ] && [ -f "$COVER" ]; then
            feh --no-fehbg --bg-max "$COVER"
        fi ) &

        # Play it
        ffplay -nodisp -autoexit "$FILE" 2> /dev/null &
        FFPLAY_PID=$!
        echo $! > "$FFPLAY_PID_FILE"
        wait $!
    done

    # Closing queue
    notif "Queue empty, stopping"
    exec 3<&-
}


# Create the directories if they don't exist yet
mkdir -p "$ZIK_DIR"
mkdir -p "$COVERS"

# Create the music queue as an actual fifo
if [ ! -p "$QUEUE" ]; then
    mkfifo "$QUEUE"
fi

# Pid of the process is/will be playing
# FIXME: refactor the two cats ?
if [ -f "$DAEMON_PID_FILE" ] && ps -p $(cat "$DAEMON_PID_FILE") > /dev/null
then
    DAEMON_PID=$(cat "$DAEMON_PID_FILE")
else
    daemon &
    echo "$!" > "$DAEMON_PID_FILE"
    DAEMON_PID=$!
fi

USAGE="Usage: $0 [--help|add <file>|menu|skip|pause|resume|stop|reset]
    Without any option, a dmenu prompt is opened to choose one.

    Options:
    --help      Print this message.
    add <file>  Add the file to the queue.
    menu        Open a menu to choose a file to add..
    skip        Go to next in queue.
    pause       Pause playback.
    resume      Resume playback.
    stop        Empty the queue and stop playing.
    reset       Remove the fifo file (use if something went wrong)."
    #query       Print the status of what is beeing played."

# Prompt for option if none was given
if [ -z $1 ]; then
    OPTIONS="Menu Skip Pause Resume Stop"
    CHOICE=$(printf "%s\n" $OPTIONS |
        dmenu -i -p "Zik"           |
        tr '[:upper:]' '[:lower:]'
    )
else 
    CHOICE=$1
fi

case "$CHOICE" in
    '--help' ) echo "$USAGE";;
    'add'    ) add "$2";;
    'menu'   ) menuadd;;
    'skip'   ) killffplay -TERM; notif "Skipping";;
    'pause'  ) killffplay -STOP; notif "Pausing" ;;
    'resume' ) killffplay -CONT; notif "Resuming";;
    'stop'   ) kill -TERM $DAEMON_PID;;
    'reset'  ) rm -f "$QUEUE"; notif "Removed fifo file $QUEUE";;
    *        ) echo "$USAGE" >&2; exit 1;;
esac
