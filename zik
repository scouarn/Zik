#!/usr/bin/sh

SEARCH_PATH="$HOME/Music"
SEARCH_EXT="wav\|mp3\|flac\|ogg"

ZIK_DIR="$HOME/.zik"
QUEUE="$ZIK_DIR/fifo"
COVER="$ZIK_DIR/cover.png"

DAEMON_PID_FILE="$ZIK_DIR/daemon_pid"
FFPLAY_PID_FILE="$ZIK_DIR/ffplay_pid"

notif() {
    notify-send "Zik" "$1"
}

# Write file to fifo
add() {
    if [ -f "$1" ]; then
        # It has to running in background because the player
        # might not have started yet
        echo "$1" > "$QUEUE"
        notif "Added $1"
    elif [ -d "$1" ]; then
        notif "This is a directory $1" 
    fi
}

# dmenu prompt to select audio file to add to queue
menuadd() {
    add "$(find "$SEARCH_PATH/" -regex ".*\.\($SEARCH_EXT\)" | # Find audio files
        awk -F '/' '{printf "%-60s%s\n", $NF, $0}'           | # Rewrite as 'file   fullpath'
        dmenu -i -l 30 -p "Choose audio file"                | # Prompt user
        sed 's#^\([^/]*\)\(.*\)$#\2#'                          # Extract back the fullpath
    )"
}

# Send signal to the ffplay child process
# SIGSTOP and SIGCONT actually work pause/resume ffplay.
killffplay() {
    if [ -f "$FFPLAY_PID_FILE" ] && ps -p $(cat "$FFPLAY_PID_FILE") > /dev/null
    then
        kill $1 $(cat "$FFPLAY_PID_FILE")
    fi
}

# This runs in the background as needed
# (stops when no more music in the queue)
daemon() {
    # Exit cleanly
    trap 'killffplay -TERM; exit' TERM INT EXIT QUIT

    # Open queue for reading : when doing read directly on $QUEUE the fifo is 
    # opened then closed so other processes trying to write are blocked.
    exec 3< "$QUEUE"

    # For each file in the queue do...
    # Exit the loop when everything has been read.
    while read -u 3 FILE; do
        [ -f "$FILE" ] || continue
        notif "Now playing $FILE" 

        # Extract cover image and set as wallpaper
        ffmpeg -y -i "$FILE" -an -vcodec copy "$COVER" 2> /dev/null &&
            feh --no-fehbg --bg-max "$COVER" -B '#000000'

        # Play it
        ffplay -nodisp -autoexit "$FILE" 2> /dev/null &
        FFPLAY_PID=$!
        echo $! > "$FFPLAY_PID_FILE"
        wait $!
    done

    # Closing queue
    notif "Queue empty, stopping"
    exec 3<&-
}



# Create the directory if it doesn't exist yet
if [ ! -d "$ZIK_DIR" ]; then
    mkdir "$ZIK_DIR"
fi

# Create the music queue as an actual fifo
if [ ! -p "$QUEUE" ]; then
    mkfifo "$QUEUE"
fi

# Pid of the process is/will be playing
if [ -f "$DAEMON_PID_FILE" ] && ps -p $(cat "$DAEMON_PID_FILE") > /dev/null
then
    DAEMON_PID=$(cat "$DAEMON_PID_FILE")
else
    daemon &
    echo "$!" > "$DAEMON_PID_FILE"
    DAEMON_PID=$!
fi

USAGE="Usage: $0 [--help|add <file>|menu|skip|pause|resume|stop|reset]
    Without any option, a dmenu prompt is opened to choose one.

    Options:
    --help      Print this message.
    add <file>  Add the file to the queue.
    menu        Open a menu to choose a file to add..
    skip        Go to next in queue.
    pause       Pause playback.
    resume      Resume playback.
    stop        Empty the queue and stop playing.
    reset       Remove the fifo file (use if something went wrong)."
    #query       Print the status of what is beeing played."


# Prompt for option if none was given
if [ -z $1 ]; then
    OPTIONS="Menu Skip Pause Resume Stop"
    CHOICE=$(printf "%s\n" $OPTIONS |
        dmenu -i -p "Zik"           |
        tr '[:upper:]' '[:lower:]'
    )
else 
    CHOICE=$1
fi

case "$CHOICE" in
    '--help' ) echo "$USAGE";;
    'add'    ) add $2;;
    'menu'   ) menuadd;;
    'skip'   ) killffplay -TERM; notif "Skipping";;
    'pause'  ) killffplay -STOP; notif "Pausing" ;;
    'resume' ) killffplay -CONT; notif "Resuming";;
    'stop'   ) kill -TERM $DAEMON_PID;;
    'reset'  ) rm -f "$QUEUE"; notif "Removed fifo file $QUEUE";;
    *        ) echo "$USAGE" >&2; exit 1;;
esac
